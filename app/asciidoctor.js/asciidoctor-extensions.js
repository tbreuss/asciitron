/* Generated by Opal 0.9.0.beta2 */
(function(Opal) {
  Opal.dynamic_require_severity = "ignore";
  var OPAL_CONFIG = { method_missing: true, arity_check: false, freezing: true, tainting: true };
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $range = Opal.range, $hash = Opal.hash;

  Opal.add_stubs(['$[]=', '$config', '$nil_or_empty?', '$name', '$grep', '$constants', '$include', '$const_get', '$extend', '$attr_reader', '$merge', '$class', '$update', '$raise', '$new', '$create_block', '$is_a?', '$has_more_lines?', '$next_block', '$<<', '$each', '$define_method', '$send', '$insert', '$dup', '$call', '$attr_accessor', '$[]', '$option', '$===', '$to_set', '$flatten', '$resolve_regexp', '$==', '$attr', '$method', '$register', '$arity', '$instance_exec', '$to_proc', '$activate', '$+', '$values', '$groups', '$add_document_processor', '$!', '$find', '$select', '$add_syntax_processor', '$to_sym', '$include?', '$private', '$tr', '$to_s', '$join', '$map', '$upcase', '$chr', '$split', '$instance_variable_get', '$instance_variable_set', '$resolve_args', '$freeze', '$process_block_given?', '$source_location', '$class_for_name', '$<', '$update_config', '$unshift', '$as_symbol', '$name=', '$pop', '$size', '$>', '$-', '$fill', '$-@', '$next_auto_id', '$generate_name', '$length', '$empty?', '$const_defined?']);
  return (function($base) {
    var self = $module($base, 'Asciidoctor');

    var def = self.$$proto, $scope = self.$$scope;

    (function($base) {
      var self = $module($base, 'Extensions');

      var def = self.$$proto, $scope = self.$$scope;

      (function($base, $super) {
        function $Processor(){};
        var self = $Processor = $klass($base, $super, 'Processor', $Processor);

        var def = self.$$proto, $scope = self.$$scope, $a, $b, TMP_1;

        def.config = nil;
        (function(self) {
          var $scope = self.$$scope, def = self.$$proto;

          Opal.defn(self, '$config', function() {
            var $a, self = this;
            if (self.config == null) self.config = nil;

            return ((($a = self.config) !== false && $a !== nil) ? $a : self.config = $hash2([], {}));
          });
          Opal.defn(self, '$option', function(key, default_value) {
            var self = this;

            return self.$config()['$[]='](key, default_value);
          });
          Opal.defn(self, '$use_dsl', function() {
            var $a, self = this;

            if ((($a = self.$name()['$nil_or_empty?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
              if ((($a = self.$constants().$grep("DSL")) !== nil && (!$a.$$is_boolean || $a == true))) {
                return self.$include(self.$const_get("DSL"))
                } else {
                return nil
              }
            } else if ((($a = self.$constants().$grep("DSL")) !== nil && (!$a.$$is_boolean || $a == true))) {
              return self.$extend(self.$const_get("DSL"))
              } else {
              return nil
            };
          });
          Opal.alias(self, 'extend_dsl', 'use_dsl');
          return Opal.alias(self, 'include_dsl', 'use_dsl');
        })(Opal.get_singleton_class(self));

        self.$attr_reader("config");

        Opal.defn(self, '$initialize', function(config) {
          var self = this;

          if (config == null) {
            config = $hash2([], {})
          }
          return self.config = self.$class().$config().$merge(config);
        });

        Opal.defn(self, '$update_config', function(config) {
          var self = this;

          return self.config.$update(config);
        });

        Opal.defn(self, '$process', function() {
          var self = this;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var args = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            args[arg_index] = arguments[arg_index + 0];
          }
          return self.$raise(Opal.get('NotImplementedError'));
        });

        Opal.defn(self, '$create_block', function(parent, context, source, attrs, opts) {
          var self = this;

          if (opts == null) {
            opts = $hash2([], {})
          }
          return $scope.get('Block').$new(parent, context, $hash2(["source", "attributes"], {"source": source, "attributes": attrs}).$merge(opts));
        });

        Opal.defn(self, '$create_image_block', function(parent, attrs, opts) {
          var self = this;

          if (opts == null) {
            opts = $hash2([], {})
          }
          return self.$create_block(parent, "image", nil, attrs, opts);
        });

        Opal.defn(self, '$create_inline', function(parent, context, text, opts) {
          var self = this;

          if (opts == null) {
            opts = $hash2([], {})
          }
          return $scope.get('Inline').$new(parent, context, text, opts);
        });

        Opal.defn(self, '$parse_content', function(parent, content, attributes) {
          var $a, $b, self = this, reader = nil, block = nil;

          if (attributes == null) {
            attributes = $hash2([], {})
          }
          reader = (function() {if ((($a = (content['$is_a?']($scope.get('Reader')))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return content
            } else {
            return ($scope.get('Reader').$new(content))
          }; return nil; })();
          while ((($b = reader['$has_more_lines?']()) !== nil && (!$b.$$is_boolean || $b == true))) {
          block = $scope.get('Parser').$next_block(reader, parent, attributes);
          if (block !== false && block !== nil) {
            parent['$<<'](block)};};
          return nil;
        });

        return ($a = ($b = [["create_paragraph", "create_block", "paragraph"], ["create_open_block", "create_block", "open"], ["create_example_block", "create_block", "example"], ["create_pass_block", "create_block", "pass"], ["create_listing_block", "create_block", "listing"], ["create_literal_block", "create_block", "literal"], ["create_anchor", "create_inline", "anchor"]]).$each, $a.$$p = (TMP_1 = function(method_name, delegate_method_name, context){var self = TMP_1.$$s || this, $a, $b, TMP_2;
if (method_name == null) method_name = nil;if (delegate_method_name == null) delegate_method_name = nil;if (context == null) context = nil;
        return ($a = ($b = self).$define_method, $a.$$p = (TMP_2 = function(args){var self = TMP_2.$$s || this, $a;
args = $slice.call(arguments, 0);
          return ($a = self).$send.apply($a, [delegate_method_name].concat(Opal.to_a(args.$dup().$insert(1, context))))}, TMP_2.$$s = self, TMP_2), $a).call($b, method_name)}, TMP_1.$$s = self, TMP_1), $a).call($b);
      })($scope.base, null);

      (function($base) {
        var self = $module($base, 'ProcessorDsl');

        var def = self.$$proto, $scope = self.$$scope, TMP_3;

        Opal.defn(self, '$option', function(key, value) {
          var self = this;

          return self.$config()['$[]='](key, value);
        });

        Opal.defn(self, '$process', TMP_3 = function() {
          var $a, self = this, $iter = TMP_3.$$p, block = $iter || nil;
          if (self.process_block == null) self.process_block = nil;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var args = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            args[arg_index] = arguments[arg_index + 0];
          }
          TMP_3.$$p = null;
          if ((block !== nil)) {
            return self.process_block = block
          } else if ((($a = self.process_block) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ($a = self.process_block).$call.apply($a, Opal.to_a(args))
            } else {
            return self.$raise(Opal.get('NotImplementedError'))
          };
        });

        Opal.defn(self, '$process_block_given?', function() {
          var $a, self = this;

          return (($a = self['process_block'], $a != null && $a !== nil) ? 'instance-variable' : nil);
        });
      })($scope.base);

      (function($base, $super) {
        function $Preprocessor(){};
        var self = $Preprocessor = $klass($base, $super, 'Preprocessor', $Preprocessor);

        var def = self.$$proto, $scope = self.$$scope;

        return (Opal.defn(self, '$process', function(document, reader) {
          var self = this;

          return self.$raise(Opal.get('NotImplementedError'));
        }), nil) && 'process'
      })($scope.base, $scope.get('Processor'));

      Opal.casgn($scope.get('Preprocessor'), 'DSL', $scope.get('ProcessorDsl'));

      (function($base, $super) {
        function $Treeprocessor(){};
        var self = $Treeprocessor = $klass($base, $super, 'Treeprocessor', $Treeprocessor);

        var def = self.$$proto, $scope = self.$$scope;

        return (Opal.defn(self, '$process', function(document) {
          var self = this;

          return self.$raise(Opal.get('NotImplementedError'));
        }), nil) && 'process'
      })($scope.base, $scope.get('Processor'));

      Opal.casgn($scope.get('Treeprocessor'), 'DSL', $scope.get('ProcessorDsl'));

      (function($base, $super) {
        function $Postprocessor(){};
        var self = $Postprocessor = $klass($base, $super, 'Postprocessor', $Postprocessor);

        var def = self.$$proto, $scope = self.$$scope;

        return (Opal.defn(self, '$process', function(document, output) {
          var self = this;

          return self.$raise(Opal.get('NotImplementedError'));
        }), nil) && 'process'
      })($scope.base, $scope.get('Processor'));

      Opal.casgn($scope.get('Postprocessor'), 'DSL', $scope.get('ProcessorDsl'));

      (function($base, $super) {
        function $IncludeProcessor(){};
        var self = $IncludeProcessor = $klass($base, $super, 'IncludeProcessor', $IncludeProcessor);

        var def = self.$$proto, $scope = self.$$scope;

        Opal.defn(self, '$process', function(document, reader, target, attributes) {
          var self = this;

          return self.$raise(Opal.get('NotImplementedError'));
        });

        return (Opal.defn(self, '$handles?', function(target) {
          var self = this;

          return true;
        }), nil) && 'handles?';
      })($scope.base, $scope.get('Processor'));

      Opal.casgn($scope.get('IncludeProcessor'), 'DSL', $scope.get('ProcessorDsl'));

      (function($base, $super) {
        function $DocinfoProcessor(){};
        var self = $DocinfoProcessor = $klass($base, $super, 'DocinfoProcessor', $DocinfoProcessor);

        var def = self.$$proto, $scope = self.$$scope, TMP_4;

        def.config = nil;
        self.$attr_accessor("location");

        Opal.defn(self, '$initialize', TMP_4 = function(config) {
          var $a, $b, $c, self = this, $iter = TMP_4.$$p, $yield = $iter || nil;

          if (config == null) {
            config = $hash2([], {})
          }
          TMP_4.$$p = null;
          Opal.find_super_dispatcher(self, 'initialize', TMP_4, null).apply(self, [config]);
          return ($a = "location", $b = self.config, ((($c = $b['$[]']($a)) !== false && $c !== nil) ? $c : $b['$[]=']($a, "head")));
        });

        return (Opal.defn(self, '$process', function(document) {
          var self = this;

          return self.$raise(Opal.get('NotImplementedError'));
        }), nil) && 'process';
      })($scope.base, $scope.get('Processor'));

      (function($base) {
        var self = $module($base, 'DocinfoProcessorDsl');

        var def = self.$$proto, $scope = self.$$scope;

        self.$include($scope.get('ProcessorDsl'));

        Opal.defn(self, '$at_location', function(value) {
          var self = this;

          return self.$option("location", value);
        });
      })($scope.base);

      Opal.casgn($scope.get('DocinfoProcessor'), 'DSL', $scope.get('DocinfoProcessorDsl'));

      (function($base, $super) {
        function $BlockProcessor(){};
        var self = $BlockProcessor = $klass($base, $super, 'BlockProcessor', $BlockProcessor);

        var def = self.$$proto, $scope = self.$$scope, TMP_5;

        def.config = nil;
        self.$attr_accessor("name");

        Opal.defn(self, '$initialize', TMP_5 = function(name, config) {
          var $a, $b, $c, self = this, $iter = TMP_5.$$p, $yield = $iter || nil, $case = nil;

          if (name == null) {
            name = nil
          }
          if (config == null) {
            config = $hash2([], {})
          }
          TMP_5.$$p = null;
          Opal.find_super_dispatcher(self, 'initialize', TMP_5, null).apply(self, [config]);
          self.name = ((($a = name) !== false && $a !== nil) ? $a : self.config['$[]']("name"));
          $case = self.config['$[]']("contexts");if (Opal.get('NilClass')['$===']($case)) {($a = "contexts", $b = self.config, ((($c = $b['$[]']($a)) !== false && $c !== nil) ? $c : $b['$[]=']($a, ["open", "paragraph"].$to_set())))}else if (Opal.get('Symbol')['$===']($case)) {self.config['$[]=']("contexts", [self.config['$[]']("contexts")].$to_set())}else {self.config['$[]=']("contexts", self.config['$[]']("contexts").$to_set())};
          return ($a = "content_model", $b = self.config, ((($c = $b['$[]']($a)) !== false && $c !== nil) ? $c : $b['$[]=']($a, "compound")));
        });

        return (Opal.defn(self, '$process', function(parent, reader, attributes) {
          var self = this;

          return self.$raise(Opal.get('NotImplementedError'));
        }), nil) && 'process';
      })($scope.base, $scope.get('Processor'));

      (function($base) {
        var self = $module($base, 'BlockProcessorDsl');

        var def = self.$$proto, $scope = self.$$scope;

        self.$include($scope.get('ProcessorDsl'));

        Opal.defn(self, '$named', function(value) {
          var $a, self = this;

          if ((($a = self['$is_a?']($scope.get('Processor'))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.name = value
            } else {
            return self.$option("name", value)
          };
        });

        Opal.alias(self, 'match_name', 'named');

        Opal.alias(self, 'bind_to', 'named');

        Opal.defn(self, '$contexts', function() {
          var self = this;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var value = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            value[arg_index] = arguments[arg_index + 0];
          }
          return self.$option("contexts", value.$flatten());
        });

        Opal.alias(self, 'on_contexts', 'contexts');

        Opal.alias(self, 'on_context', 'contexts');

        Opal.defn(self, '$content_model', function(value) {
          var self = this;

          return self.$option("content_model", value);
        });

        Opal.alias(self, 'parse_content_as', 'content_model');

        Opal.defn(self, '$positional_attributes', function() {
          var self = this;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var value = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            value[arg_index] = arguments[arg_index + 0];
          }
          return self.$option("pos_attrs", value.$flatten());
        });

        Opal.alias(self, 'pos_attrs', 'positional_attributes');

        Opal.alias(self, 'name_attributes', 'positional_attributes');

        Opal.alias(self, 'name_positional_attributes', 'positional_attributes');

        Opal.defn(self, '$default_attrs', function(value) {
          var self = this;

          return self.$option("default_attrs", value);
        });

        Opal.alias(self, 'seed_attributes_with', 'default_attrs');
      })($scope.base);

      Opal.casgn($scope.get('BlockProcessor'), 'DSL', $scope.get('BlockProcessorDsl'));

      (function($base, $super) {
        function $MacroProcessor(){};
        var self = $MacroProcessor = $klass($base, $super, 'MacroProcessor', $MacroProcessor);

        var def = self.$$proto, $scope = self.$$scope, TMP_6;

        def.config = nil;
        self.$attr_accessor("name");

        Opal.defn(self, '$initialize', TMP_6 = function(name, config) {
          var $a, $b, $c, self = this, $iter = TMP_6.$$p, $yield = $iter || nil;

          if (name == null) {
            name = nil
          }
          if (config == null) {
            config = $hash2([], {})
          }
          TMP_6.$$p = null;
          Opal.find_super_dispatcher(self, 'initialize', TMP_6, null).apply(self, [config]);
          self.name = ((($a = name) !== false && $a !== nil) ? $a : self.config['$[]']("name"));
          return ($a = "content_model", $b = self.config, ((($c = $b['$[]']($a)) !== false && $c !== nil) ? $c : $b['$[]=']($a, "attributes")));
        });

        return (Opal.defn(self, '$process', function(parent, target, attributes) {
          var self = this;

          return self.$raise(Opal.get('NotImplementedError'));
        }), nil) && 'process';
      })($scope.base, $scope.get('Processor'));

      (function($base) {
        var self = $module($base, 'MacroProcessorDsl');

        var def = self.$$proto, $scope = self.$$scope;

        self.$include($scope.get('ProcessorDsl'));

        Opal.defn(self, '$named', function(value) {
          var $a, self = this;

          if ((($a = self['$is_a?']($scope.get('Processor'))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.name = value
            } else {
            return self.$option("name", value)
          };
        });

        Opal.alias(self, 'match_name', 'named');

        Opal.alias(self, 'bind_to', 'named');

        Opal.defn(self, '$content_model', function(value) {
          var self = this;

          return self.$option("content_model", value);
        });

        Opal.alias(self, 'parse_content_as', 'content_model');

        Opal.defn(self, '$positional_attributes', function() {
          var self = this;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var value = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            value[arg_index] = arguments[arg_index + 0];
          }
          return self.$option("pos_attrs", value.$flatten());
        });

        Opal.alias(self, 'pos_attrs', 'positional_attributes');

        Opal.alias(self, 'name_attributes', 'positional_attributes');

        Opal.alias(self, 'name_positional_attributes', 'positional_attributes');

        Opal.defn(self, '$default_attrs', function(value) {
          var self = this;

          return self.$option("default_attrs", value);
        });

        Opal.alias(self, 'seed_attributes_with', 'default_attrs');
      })($scope.base);

      (function($base, $super) {
        function $BlockMacroProcessor(){};
        var self = $BlockMacroProcessor = $klass($base, $super, 'BlockMacroProcessor', $BlockMacroProcessor);

        var def = self.$$proto, $scope = self.$$scope;

        return nil;
      })($scope.base, $scope.get('MacroProcessor'));

      Opal.casgn($scope.get('BlockMacroProcessor'), 'DSL', $scope.get('MacroProcessorDsl'));

      (function($base, $super) {
        function $InlineMacroProcessor(){};
        var self = $InlineMacroProcessor = $klass($base, $super, 'InlineMacroProcessor', $InlineMacroProcessor);

        var def = self.$$proto, $scope = self.$$scope;

        def.config = def.name = nil;
        Opal.defn(self, '$regexp', function() {
          var $a, $b, $c, self = this;

          return ($a = "regexp", $b = self.config, ((($c = $b['$[]']($a)) !== false && $c !== nil) ? $c : $b['$[]=']($a, (self.$resolve_regexp(self.name, self.config['$[]']("format"))))));
        });

        return (Opal.defn(self, '$resolve_regexp', function(name, format) {
          var self = this;

          if (format['$==']("short")) {
            return (new RegExp("\\\\?" + name + ":\\[((?:\\\\\\]|[^\\]])*?)\\]"))
            } else {
            return (new RegExp("\\\\?" + name + ":(\\S+?)\\[((?:\\\\\\]|[^\\]])*?)\\]"))
          };
        }), nil) && 'resolve_regexp';
      })($scope.base, $scope.get('MacroProcessor'));

      (function($base) {
        var self = $module($base, 'InlineMacroProcessorDsl');

        var def = self.$$proto, $scope = self.$$scope;

        self.$include($scope.get('MacroProcessorDsl'));

        Opal.defn(self, '$using_format', function(value) {
          var self = this;

          return self.$option("format", value);
        });

        Opal.defn(self, '$match', function(value) {
          var self = this;

          return self.$option("regexp", value);
        });
      })($scope.base);

      Opal.casgn($scope.get('InlineMacroProcessor'), 'DSL', $scope.get('InlineMacroProcessorDsl'));

      (function($base, $super) {
        function $Extension(){};
        var self = $Extension = $klass($base, $super, 'Extension', $Extension);

        var def = self.$$proto, $scope = self.$$scope;

        self.$attr("kind");

        self.$attr("config");

        self.$attr("instance");

        return (Opal.defn(self, '$initialize', function(kind, instance, config) {
          var self = this;

          self.kind = kind;
          self.instance = instance;
          return self.config = config;
        }), nil) && 'initialize';
      })($scope.base, null);

      (function($base, $super) {
        function $ProcessorExtension(){};
        var self = $ProcessorExtension = $klass($base, $super, 'ProcessorExtension', $ProcessorExtension);

        var def = self.$$proto, $scope = self.$$scope, TMP_7;

        self.$attr("process_method");

        return (Opal.defn(self, '$initialize', TMP_7 = function(kind, instance, process_method) {
          var $a, self = this, $iter = TMP_7.$$p, $yield = $iter || nil;

          if (process_method == null) {
            process_method = nil
          }
          TMP_7.$$p = null;
          Opal.find_super_dispatcher(self, 'initialize', TMP_7, null).apply(self, [kind, instance, instance.$config()]);
          return self.process_method = ((($a = process_method) !== false && $a !== nil) ? $a : (instance.$method("process")));
        }), nil) && 'initialize';
      })($scope.base, $scope.get('Extension'));

      (function($base, $super) {
        function $Group(){};
        var self = $Group = $klass($base, $super, 'Group', $Group);

        var def = self.$$proto, $scope = self.$$scope;

        (function(self) {
          var $scope = self.$$scope, def = self.$$proto;

          return (Opal.defn(self, '$register', function(name) {
            var self = this;

            if (name == null) {
              name = nil
            }
            return $scope.get('Extensions').$register(name, self);
          }), nil) && 'register'
        })(Opal.get_singleton_class(self));

        return (Opal.defn(self, '$activate', function(registry) {
          var self = this;

          return self.$raise(Opal.get('NotImplementedError'));
        }), nil) && 'activate';
      })($scope.base, null);

      (function($base, $super) {
        function $Registry(){};
        var self = $Registry = $klass($base, $super, 'Registry', $Registry);

        var def = self.$$proto, $scope = self.$$scope, TMP_9, TMP_10, TMP_11, TMP_12, TMP_13, TMP_16, TMP_17, TMP_18, TMP_19, TMP_21;

        def.groups = def.preprocessor_extensions = def.treeprocessor_extensions = def.postprocessor_extensions = def.include_processor_extensions = def.docinfo_processor_extensions = def.block_extensions = def.block_macro_extensions = def.inline_macro_extensions = nil;
        self.$attr_reader("document");

        self.$attr_reader("groups");

        Opal.defn(self, '$initialize', function(groups) {
          var self = this;

          if (groups == null) {
            groups = $hash2([], {})
          }
          self.groups = groups;
          self.preprocessor_extensions = self.treeprocessor_extensions = self.postprocessor_extensions = self.include_processor_extensions = self.docinfo_processor_extensions = nil;
          self.block_extensions = self.block_macro_extensions = self.inline_macro_extensions = nil;
          return self.document = nil;
        });

        Opal.defn(self, '$activate', function(document) {
          var $a, $b, TMP_8, self = this;

          self.document = document;
          ($a = ($b = ($rb_plus($scope.get('Extensions').$groups().$values(), self.groups.$values()))).$each, $a.$$p = (TMP_8 = function(group){var self = TMP_8.$$s || this, $a, $b, $case = nil;
if (group == null) group = nil;
          return (function() {$case = group;if (Opal.get('Proc')['$===']($case)) {return (function() {$case = group.$arity();if ((0)['$===']($case) || (-1)['$===']($case)) {return ($a = ($b = self).$instance_exec, $a.$$p = group.$to_proc(), $a).call($b)}else if ((1)['$===']($case)) {return group.$call(self)}else { return nil }})()}else if (Opal.get('Class')['$===']($case)) {return group.$new().$activate(self)}else {return group.$activate(self)}})()}, TMP_8.$$s = self, TMP_8), $a).call($b);
          return self;
        });

        Opal.defn(self, '$preprocessor', TMP_9 = function() {
          var $a, $b, self = this, $iter = TMP_9.$$p, block = $iter || nil;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var args = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            args[arg_index] = arguments[arg_index + 0];
          }
          TMP_9.$$p = null;
          return ($a = ($b = self).$add_document_processor, $a.$$p = block.$to_proc(), $a).call($b, "preprocessor", args);
        });

        Opal.defn(self, '$preprocessors?', function() {
          var self = this;

          return self.preprocessor_extensions['$!']()['$!']();
        });

        Opal.defn(self, '$preprocessors', function() {
          var self = this;

          return self.preprocessor_extensions;
        });

        Opal.defn(self, '$treeprocessor', TMP_10 = function() {
          var $a, $b, self = this, $iter = TMP_10.$$p, block = $iter || nil;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var args = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            args[arg_index] = arguments[arg_index + 0];
          }
          TMP_10.$$p = null;
          return ($a = ($b = self).$add_document_processor, $a.$$p = block.$to_proc(), $a).call($b, "treeprocessor", args);
        });

        Opal.defn(self, '$treeprocessors?', function() {
          var self = this;

          return self.treeprocessor_extensions['$!']()['$!']();
        });

        Opal.defn(self, '$treeprocessors', function() {
          var self = this;

          return self.treeprocessor_extensions;
        });

        Opal.defn(self, '$postprocessor', TMP_11 = function() {
          var $a, $b, self = this, $iter = TMP_11.$$p, block = $iter || nil;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var args = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            args[arg_index] = arguments[arg_index + 0];
          }
          TMP_11.$$p = null;
          return ($a = ($b = self).$add_document_processor, $a.$$p = block.$to_proc(), $a).call($b, "postprocessor", args);
        });

        Opal.defn(self, '$postprocessors?', function() {
          var self = this;

          return self.postprocessor_extensions['$!']()['$!']();
        });

        Opal.defn(self, '$postprocessors', function() {
          var self = this;

          return self.postprocessor_extensions;
        });

        Opal.defn(self, '$include_processor', TMP_12 = function() {
          var $a, $b, self = this, $iter = TMP_12.$$p, block = $iter || nil;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var args = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            args[arg_index] = arguments[arg_index + 0];
          }
          TMP_12.$$p = null;
          return ($a = ($b = self).$add_document_processor, $a.$$p = block.$to_proc(), $a).call($b, "include_processor", args);
        });

        Opal.defn(self, '$include_processors?', function() {
          var self = this;

          return self.include_processor_extensions['$!']()['$!']();
        });

        Opal.defn(self, '$include_processors', function() {
          var self = this;

          return self.include_processor_extensions;
        });

        Opal.defn(self, '$docinfo_processor', TMP_13 = function() {
          var $a, $b, self = this, $iter = TMP_13.$$p, block = $iter || nil;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var args = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            args[arg_index] = arguments[arg_index + 0];
          }
          TMP_13.$$p = null;
          return ($a = ($b = self).$add_document_processor, $a.$$p = block.$to_proc(), $a).call($b, "docinfo_processor", args);
        });

        Opal.defn(self, '$docinfo_processors?', function(location) {
          var $a, $b, TMP_14, self = this;

          if (location == null) {
            location = nil
          }
          if ((($a = self.docinfo_processor_extensions) !== nil && (!$a.$$is_boolean || $a == true))) {
            if (location !== false && location !== nil) {
              return ($a = ($b = self.docinfo_processor_extensions).$find, $a.$$p = (TMP_14 = function(ext){var self = TMP_14.$$s || this;
if (ext == null) ext = nil;
              return ext.$config()['$[]']("location")['$=='](location)}, TMP_14.$$s = self, TMP_14), $a).call($b)
              } else {
              return true
            }
            } else {
            return false
          };
        });

        Opal.defn(self, '$docinfo_processors', function(location) {
          var $a, $b, TMP_15, self = this;

          if (location == null) {
            location = nil
          }
          if ((($a = self.docinfo_processor_extensions) !== nil && (!$a.$$is_boolean || $a == true))) {
            if (location !== false && location !== nil) {
              return ($a = ($b = self.docinfo_processor_extensions).$select, $a.$$p = (TMP_15 = function(ext){var self = TMP_15.$$s || this;
if (ext == null) ext = nil;
              return ext.$config()['$[]']("location")['$=='](location)}, TMP_15.$$s = self, TMP_15), $a).call($b)
              } else {
              return self.docinfo_processor_extensions
            }
            } else {
            return nil
          };
        });

        Opal.defn(self, '$block', TMP_16 = function() {
          var $a, $b, self = this, $iter = TMP_16.$$p, block = $iter || nil;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var args = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            args[arg_index] = arguments[arg_index + 0];
          }
          TMP_16.$$p = null;
          return ($a = ($b = self).$add_syntax_processor, $a.$$p = block.$to_proc(), $a).call($b, "block", args);
        });

        Opal.defn(self, '$blocks?', function() {
          var self = this;

          return self.block_extensions['$!']()['$!']();
        });

        Opal.defn(self, '$registered_for_block?', function(name, context) {
          var $a, self = this, ext = nil;

          if ((($a = (ext = self.block_extensions['$[]'](name.$to_sym()))) !== nil && (!$a.$$is_boolean || $a == true))) {
            if ((($a = (ext.$config()['$[]']("contexts")['$include?'](context))) !== nil && (!$a.$$is_boolean || $a == true))) {
              return ext
              } else {
              return false
            }
            } else {
            return false
          };
        });

        Opal.defn(self, '$find_block_extension', function(name) {
          var self = this;

          return self.block_extensions['$[]'](name.$to_sym());
        });

        Opal.defn(self, '$block_macro', TMP_17 = function() {
          var $a, $b, self = this, $iter = TMP_17.$$p, block = $iter || nil;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var args = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            args[arg_index] = arguments[arg_index + 0];
          }
          TMP_17.$$p = null;
          return ($a = ($b = self).$add_syntax_processor, $a.$$p = block.$to_proc(), $a).call($b, "block_macro", args);
        });

        Opal.defn(self, '$block_macros?', function() {
          var self = this;

          return self.block_macro_extensions['$!']()['$!']();
        });

        Opal.defn(self, '$registered_for_block_macro?', function(name) {
          var $a, self = this, ext = nil;

          if ((($a = (ext = self.block_macro_extensions['$[]'](name.$to_sym()))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ext
            } else {
            return false
          };
        });

        Opal.defn(self, '$find_block_macro_extension', function(name) {
          var self = this;

          return self.block_macro_extensions['$[]'](name.$to_sym());
        });

        Opal.defn(self, '$inline_macro', TMP_18 = function() {
          var $a, $b, self = this, $iter = TMP_18.$$p, block = $iter || nil;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var args = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            args[arg_index] = arguments[arg_index + 0];
          }
          TMP_18.$$p = null;
          return ($a = ($b = self).$add_syntax_processor, $a.$$p = block.$to_proc(), $a).call($b, "inline_macro", args);
        });

        Opal.defn(self, '$inline_macros?', function() {
          var self = this;

          return self.inline_macro_extensions['$!']()['$!']();
        });

        Opal.defn(self, '$registered_for_inline_macro?', function(name) {
          var $a, self = this, ext = nil;

          if ((($a = (ext = self.inline_macro_extensions['$[]'](name.$to_sym()))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return ext
            } else {
            return false
          };
        });

        Opal.defn(self, '$find_inline_macro_extension', function(name) {
          var self = this;

          return self.inline_macro_extensions['$[]'](name.$to_sym());
        });

        Opal.defn(self, '$inline_macros', function() {
          var self = this;

          return self.inline_macro_extensions.$values();
        });

        self.$private();

        Opal.defn(self, '$add_document_processor', TMP_19 = function(kind, args) {
          var $a, $b, TMP_20, $c, $d, $e, self = this, $iter = TMP_19.$$p, block = $iter || nil, kind_name = nil, kind_class_symbol = nil, kind_class = nil, kind_java_class = nil, kind_store = nil, extension = nil, config = nil, processor = nil, processor_instance = nil;

          TMP_19.$$p = null;
          kind_name = kind.$to_s().$tr("_", " ");
          kind_class_symbol = ($a = ($b = kind_name.$split(" ")).$map, $a.$$p = (TMP_20 = function(word){var self = TMP_20.$$s || this;
if (word == null) word = nil;
          return "" + (word.$chr().$upcase()) + (word['$[]']($range(1, -1, false)))}, TMP_20.$$s = self, TMP_20), $a).call($b).$join().$to_sym();
          kind_class = $scope.get('Extensions').$const_get(kind_class_symbol);
          kind_java_class = (function() {if ((($a = ((Opal.Object.$$scope.AsciidoctorJ == null ? nil : 'constant'))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return (((Opal.get('AsciidoctorJ')).$$scope.get('Extensions')).$const_get(kind_class_symbol))
            } else {
            return nil
          }; return nil; })();
          kind_store = ((($a = self.$instance_variable_get(((("@") + (kind)) + "_extensions").$to_sym())) !== false && $a !== nil) ? $a : self.$instance_variable_set(((("@") + (kind)) + "_extensions").$to_sym(), []));
          extension = (function() {if ((block !== nil)) {
            config = self.$resolve_args(args, 1);
            processor = kind_class.$new(config);
            if ((($a = kind_class.$constants().$grep("DSL")) !== nil && (!$a.$$is_boolean || $a == true))) {
              processor.$extend(kind_class.$const_get("DSL"))};
            ($a = ($c = processor).$instance_exec, $a.$$p = block.$to_proc(), $a).call($c);
            processor.$freeze();
            if ((($a = processor['$process_block_given?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
              } else {
              self.$raise(Opal.get('ArgumentError').$new("No block specified to process " + (kind_name) + " extension at " + (block.$source_location())))
            };
            return $scope.get('ProcessorExtension').$new(kind, processor);
            } else {
            $a = Opal.to_ary(self.$resolve_args(args, 2)), processor = ($a[0] == null ? nil : $a[0]), config = ($a[1] == null ? nil : $a[1]);
            if ((($a = ((($d = (processor['$is_a?'](Opal.get('Class')))) !== false && $d !== nil) ? $d : (($e = (processor['$is_a?'](Opal.get('String'))), $e !== false && $e !== nil ?(processor = $scope.get('Extensions').$class_for_name(processor)) : $e)))) !== nil && (!$a.$$is_boolean || $a == true))) {
              if ((($a = ((($d = $rb_lt(processor, kind_class)) !== false && $d !== nil) ? $d : ((($e = kind_java_class !== false && kind_java_class !== nil) ? $rb_lt(processor, kind_java_class) : kind_java_class)))) !== nil && (!$a.$$is_boolean || $a == true))) {
                } else {
                self.$raise(Opal.get('ArgumentError').$new("Invalid type for " + (kind_name) + " extension: " + (processor)))
              };
              processor_instance = processor.$new(config);
              processor_instance.$freeze();
              return $scope.get('ProcessorExtension').$new(kind, processor_instance);
            } else if ((($a = ((($d = (processor['$is_a?'](kind_class))) !== false && $d !== nil) ? $d : ((($e = kind_java_class !== false && kind_java_class !== nil) ? (processor['$is_a?'](kind_java_class)) : kind_java_class)))) !== nil && (!$a.$$is_boolean || $a == true))) {
              processor.$update_config(config);
              processor.$freeze();
              return $scope.get('ProcessorExtension').$new(kind, processor);
              } else {
              return self.$raise(Opal.get('ArgumentError').$new("Invalid arguments specified for registering " + (kind_name) + " extension: " + (args)))
            };
          }; return nil; })();
          if (extension.$config()['$[]']("position")['$=='](">>")) {
            return kind_store.$unshift(extension)
            } else {
            return kind_store['$<<'](extension)
          };
        });

        Opal.defn(self, '$add_syntax_processor', TMP_21 = function(kind, args) {
          var $a, $b, TMP_22, $c, $d, $e, self = this, $iter = TMP_21.$$p, block = $iter || nil, kind_name = nil, kind_class_basename = nil, kind_class_symbol = nil, kind_class = nil, kind_java_class = nil, kind_store = nil, name = nil, config = nil, processor = nil, processor_instance = nil;

          TMP_21.$$p = null;
          kind_name = kind.$to_s().$tr("_", " ");
          kind_class_basename = ($a = ($b = kind_name.$split(" ")).$map, $a.$$p = (TMP_22 = function(word){var self = TMP_22.$$s || this;
if (word == null) word = nil;
          return "" + (word.$chr().$upcase()) + (word['$[]']($range(1, -1, false)))}, TMP_22.$$s = self, TMP_22), $a).call($b).$join();
          kind_class_symbol = ((("") + (kind_class_basename)) + "Processor").$to_sym();
          kind_class = $scope.get('Extensions').$const_get(kind_class_symbol);
          kind_java_class = (function() {if ((($a = ((Opal.Object.$$scope.AsciidoctorJ == null ? nil : 'constant'))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return (((Opal.get('AsciidoctorJ')).$$scope.get('Extensions')).$const_get(kind_class_symbol))
            } else {
            return nil
          }; return nil; })();
          kind_store = ((($a = self.$instance_variable_get(((("@") + (kind)) + "_extensions").$to_sym())) !== false && $a !== nil) ? $a : self.$instance_variable_set(((("@") + (kind)) + "_extensions").$to_sym(), $hash2([], {})));
          if ((block !== nil)) {
            $a = Opal.to_ary(self.$resolve_args(args, 2)), name = ($a[0] == null ? nil : $a[0]), config = ($a[1] == null ? nil : $a[1]);
            processor = kind_class.$new(self.$as_symbol(name), config);
            if ((($a = kind_class.$constants().$grep("DSL")) !== nil && (!$a.$$is_boolean || $a == true))) {
              processor.$extend(kind_class.$const_get("DSL"))};
            if (block.$arity()['$=='](1)) {
              if (Opal.yield1(block, processor) === $breaker) return $breaker.$v
              } else {
              ($a = ($c = processor).$instance_exec, $a.$$p = block.$to_proc(), $a).call($c)
            };
            if ((($a = (name = self.$as_symbol(processor.$name()))) !== nil && (!$a.$$is_boolean || $a == true))) {
              } else {
              self.$raise(Opal.get('ArgumentError').$new("No name specified for " + (kind_name) + " extension at " + (block.$source_location())))
            };
            if ((($a = processor['$process_block_given?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
              } else {
              self.$raise(Opal.get('NoMethodError').$new("No block specified to process " + (kind_name) + " extension at " + (block.$source_location())))
            };
            processor.$freeze();
            return kind_store['$[]='](name, $scope.get('ProcessorExtension').$new(kind, processor));
            } else {
            $a = Opal.to_ary(self.$resolve_args(args, 3)), processor = ($a[0] == null ? nil : $a[0]), name = ($a[1] == null ? nil : $a[1]), config = ($a[2] == null ? nil : $a[2]);
            if ((($a = ((($d = (processor['$is_a?'](Opal.get('Class')))) !== false && $d !== nil) ? $d : (($e = (processor['$is_a?'](Opal.get('String'))), $e !== false && $e !== nil ?(processor = $scope.get('Extensions').$class_for_name(processor)) : $e)))) !== nil && (!$a.$$is_boolean || $a == true))) {
              if ((($a = ((($d = $rb_lt(processor, kind_class)) !== false && $d !== nil) ? $d : ((($e = kind_java_class !== false && kind_java_class !== nil) ? $rb_lt(processor, kind_java_class) : kind_java_class)))) !== nil && (!$a.$$is_boolean || $a == true))) {
                } else {
                self.$raise(Opal.get('ArgumentError').$new("Class specified for " + (kind_name) + " extension does not inherit from " + (kind_class) + ": " + (processor)))
              };
              processor_instance = processor.$new(self.$as_symbol(name), config);
              if ((($a = (name = self.$as_symbol(processor_instance.$name()))) !== nil && (!$a.$$is_boolean || $a == true))) {
                } else {
                self.$raise(Opal.get('ArgumentError').$new("No name specified for " + (kind_name) + " extension: " + (processor)))
              };
              processor.$freeze();
              return kind_store['$[]='](name, $scope.get('ProcessorExtension').$new(kind, processor_instance));
            } else if ((($a = ((($d = (processor['$is_a?'](kind_class))) !== false && $d !== nil) ? $d : ((($e = kind_java_class !== false && kind_java_class !== nil) ? (processor['$is_a?'](kind_java_class)) : kind_java_class)))) !== nil && (!$a.$$is_boolean || $a == true))) {
              processor.$update_config(config);
              if ((($a = (name = (function() {if (name !== false && name !== nil) {
                return ((($d = [self.$as_symbol(name)]), $e = processor, $e['$name='].apply($e, $d), $d[$d.length-1]))
                } else {
                return (self.$as_symbol(processor.$name()))
              }; return nil; })())) !== nil && (!$a.$$is_boolean || $a == true))) {
                } else {
                self.$raise(Opal.get('ArgumentError').$new("No name specified for " + (kind_name) + " extension: " + (processor)))
              };
              processor.$freeze();
              return kind_store['$[]='](name, $scope.get('ProcessorExtension').$new(kind, processor));
              } else {
              return self.$raise(Opal.get('ArgumentError').$new("Invalid arguments specified for registering " + (kind_name) + " extension: " + (args)))
            };
          };
        });

        Opal.defn(self, '$resolve_args', function(args, expect) {
          var $a, self = this, opts = nil, num_args = nil, missing = nil;

          opts = (function() {if ((($a = (args['$[]'](-1)['$is_a?'](Opal.get('Hash')))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return args.$pop()
            } else {
            return $hash2([], {})
          }; return nil; })();
          if (expect['$=='](1)) {
            return opts};
          num_args = args.$size();
          if ($rb_gt((missing = $rb_minus($rb_minus(expect, 1), num_args)), 0)) {
            args.$fill(nil, num_args, missing)
          } else if ($rb_lt(missing, 0)) {
            args.$pop(missing['$-@']())};
          args['$<<'](opts);
          return args;
        });

        return (Opal.defn(self, '$as_symbol', function(name) {
          var $a, self = this;

          if (name !== false && name !== nil) {
            return ((function() {if ((($a = (name['$is_a?'](Opal.get('Symbol')))) !== nil && (!$a.$$is_boolean || $a == true))) {
              return name
              } else {
              return name.$to_sym()
            }; return nil; })())
            } else {
            return nil
          };
        }), nil) && 'as_symbol';
      })($scope.base, null);

      (function(self) {
        var $scope = self.$$scope, def = self.$$proto, TMP_23, TMP_24;

        Opal.defn(self, '$generate_name', function() {
          var self = this;

          return "extgrp" + (self.$next_auto_id());
        });
        Opal.defn(self, '$next_auto_id', function() {
          var $a, self = this;
          if (self.auto_id == null) self.auto_id = nil;

          ((($a = self.auto_id) !== false && $a !== nil) ? $a : self.auto_id = -1);
          return self.auto_id = $rb_plus(self.auto_id, 1);
        });
        Opal.defn(self, '$groups', function() {
          var $a, self = this;
          if (self.groups == null) self.groups = nil;

          return ((($a = self.groups) !== false && $a !== nil) ? $a : self.groups = $hash2([], {}));
        });
        Opal.defn(self, '$build_registry', TMP_23 = function(name) {
          var $a, self = this, $iter = TMP_23.$$p, block = $iter || nil;

          if (name == null) {
            name = nil
          }
          TMP_23.$$p = null;
          if ((block !== nil)) {
            ((($a = name) !== false && $a !== nil) ? $a : name = self.$generate_name());
            return $scope.get('Registry').$new($hash(name, block));
            } else {
            return $scope.get('Registry').$new()
          };
        });
        Opal.defn(self, '$register', TMP_24 = function() {
          var $a, self = this, $iter = TMP_24.$$p, block = $iter || nil, argc = nil, resolved_group = nil, group = nil, $case = nil, name = nil;

          var array_size = arguments.length - 0;
          if(array_size < 0) array_size = 0;
          var args = new Array(array_size);
          for(var arg_index = 0; arg_index < array_size; arg_index++) {
            args[arg_index] = arguments[arg_index + 0];
          }
          TMP_24.$$p = null;
          argc = args.$length();
          resolved_group = (function() {if ((block !== nil)) {
            return block
          } else if ((($a = ((group = args.$pop()))['$!']()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$raise(Opal.get('ArgumentError').$new("Extension group to register not specified"))
            } else {
            return (function() {$case = group;if (Opal.get('Class')['$===']($case)) {return group}else if (Opal.get('String')['$===']($case)) {return self.$class_for_name(group)}else if (Opal.get('Symbol')['$===']($case)) {return self.$class_for_name(group.$to_s())}else {return group}})()
          }; return nil; })();
          name = ((($a = args.$pop()) !== false && $a !== nil) ? $a : self.$generate_name());
          if ((($a = args['$empty?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
            } else {
            self.$raise(Opal.get('ArgumentError').$new("Wrong number of arguments (" + (argc) + " for 1..2)"))
          };
          return self.$groups()['$[]='](name, resolved_group);
        });
        Opal.defn(self, '$unregister_all', function() {
          var self = this;

          return self.groups = $hash2([], {});
        });
        Opal.defn(self, '$resolve_class', function(object) {
          var $a, self = this;

          if ((($a = (object['$is_a?'](Opal.get('Class')))) !== nil && (!$a.$$is_boolean || $a == true))) {
            return object
            } else {
            return (self.$class_for_name(object.$to_s()))
          };
        });
        return (Opal.defn(self, '$class_for_name', function(qualified_name) {
          var $a, $b, TMP_25, self = this, resolved_class = nil;

          resolved_class = Opal.get('Object');
          ($a = ($b = qualified_name.$split("::")).$each, $a.$$p = (TMP_25 = function(name){var self = TMP_25.$$s || this, $a;
if (name == null) name = nil;
          if ((($a = name['$empty?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
              return nil
            } else if ((($a = resolved_class['$const_defined?'](name)) !== nil && (!$a.$$is_boolean || $a == true))) {
              return resolved_class = resolved_class.$const_get(name)
              } else {
              return self.$raise("Could not resolve class for name: " + (qualified_name))
            }}, TMP_25.$$s = self, TMP_25), $a).call($b);
          return resolved_class;
        }), nil) && 'class_for_name';
      })(Opal.get_singleton_class(self));
    })($scope.base)
  })($scope.base)
})(Opal);

/* Generated by Opal 0.9.0.beta2 */
(function(Opal) {
  Opal.dynamic_require_severity = "ignore";
  var OPAL_CONFIG = { method_missing: true, arity_check: false, freezing: true, tainting: true };
  var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  return nil
})(Opal);
